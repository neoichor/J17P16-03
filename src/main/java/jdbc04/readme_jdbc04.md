# jdbc04: 本格的なCRUDアプリケーションの設計と実装

## 1. jdbc04の目的

`jdbc01`から`jdbc03`までで、JDBCの基本的な接続、CRUD操作、そしてトランザクション管理について学びました。`jdbc04`からは、これまでの知識を総動員し、より実践的で堅牢なコンソールベースのCRUDアプリケーションの開発に入ります。

最初のステップとして、家計簿（Cashbook）の費目を管理する`item`テーブルのCRUD機能から実装します。この過程を通じて、単に動くだけでなく、**保守しやすく、読みやすく、そして安全なプログラムをどう設計していくか**を学びます。

## 2. jdbc04で学ぶ、プログラム設計の基本原則

### 2.1. 単一責任の原則 (SRP: Single Responsibility Principle)

`ItemInsert.java`や`ItemUpdate.java`の`main`メソッドを見ると、以前のバージョンに比べて非常にスッキリしていることが分かります。これは、各メソッドやクラスが持つべき責任を明確に分離した結果です。

-   **UIクラス (`ItemInsert`など):** ユーザーからの入力を受け付け、表示するという**UIの責任**に集中します。
-   **DAOクラス (`ItemDAO`):** データベースとのやり取りという**永続化の責任**に集中します。
-   **DTOクラス (`ItemDTO`):** データを運ぶという**データ転送の責任**に集中します。
-   **ユーティリティクラス (`ConsoleUtils`, `StringUtils`):** 複数の場所で使われる共通処理を提供する**支援の責任**に集中します。

このように責任を分離することで、コードの再利用性が高まり、変更が必要になった場合の影響範囲を限定することができます。

### 2.2. privateメソッドによるロジックの分割と可読性の向上

`ItemUpdate.java`には`selectItemById()`や`inputNewItemName()`といった`private`メソッドが定義されています。

**privateメソッドとは？**
そのクラスの内部からしか呼び出すことができないメソッドです。外部から隠蔽されているため、クラスの作者は、他のクラスからの影響を気にすることなく、自由にメソッドの追加や変更ができます。

`main`メソッドのようなメインロジックから、特定の詳細な処理（IDの入力受付、名前の入力受付など）を`private`メソッドとして切り出すことで、以下のようなメリットが生まれます。

1.  **メインロジックがスッキリする:** `main`メソッドは「IDを選んで、新しい名前を入力して、更新する」という大まかな流れだけを記述すればよくなり、コードの可読性が劇的に向上します。
2.  **再利用性:** クラス内であれば、同じ処理を何度も呼び出すことができます。
3.  **関心事の分離:** 「IDを選択する」という関心事を一つのメソッドに閉じ込めることで、その処理に関する修正はそのメソッド内だけで完結します。

### 2.3. ユーティリティクラスによる機能の共通化

`ConsoleUtils`や`StringUtils`のように、特定の処理に特化した共通機能をまとめたクラスを**ユーティリティクラス**と呼びます。

**なぜstaticメソッドが多いのか？**
ユーティリティクラスのメソッドは、特定のインスタンス（オブジェクトの状態）に依存しない、汎用的な処理であることがほとんどです。例えば「文字列が空かどうかを判定する」処理は、対象の文字列さえあれば、他に何も情報を必要としません。

このような処理は、`new ConsoleUtils()`のように**インスタンスを生成するまでもなく**、`ConsoleUtils.printItemList()`のようにクラス名から直接呼び出せる`static`メソッドとして定義するのが合理的です。これにより、メモリの節約になり、呼び出しも簡潔になります。

## 3. 安全で親切なアプリケーションを作るための技術

### 3.1. 利用者を迷わせないUIの標準化

`ItemInsert`や`ItemUpdate`など、どの機能を使っても、IDの入力方法、エラーメッセージの表示形式、終了の仕方が統一されています。これは`ConsoleUtils`や`private`メソッドによるUIロジックの共通化によって実現されています。

利用者が「この画面ではどう操作するんだっけ？」と迷うことがないように、アプリケーション全体でUIの振る舞いを標準化することは、使いやすいソフトウェアの基本です。

### 3.2. 丁寧な例外処理

良いアプリケーションは、予期せぬエラーが起きても、パニック（突然の強制終了）に陥らず、利用者に状況を伝えて正常な状態を保とうとします。

-   **外部キー制約違反の個別対応:** `ItemDelete`では、家計簿データで使われている品目を削除しようとした際に発生する`SQLException`を特別に扱っています。`e.getSQLState()`をチェックし、それが外部キー制約違反を示す`"23503"`であれば、「使用中なので削除できません」という、利用者にとって分かりやすいメッセージを表示します。
-   **マジックナンバーの排除:** `"23503"`のような、意味が分かりにくいリテラル（マジックナンバー）を直接コードに書くのではなく、`private static final String FOREIGN_KEY_VIOLATION = "23503";` のように名前付きの定数にすることで、コードの意図が明確になります。
-   **エラー情報の分離:** `ConsoleUtils.handleDatabaseError()`では、利用者向けのエラーメッセージと、開発者向けの技術的な情報（スタックトレース）を分けて表示しています。これにより、利用者を混乱させることなく、デバッグに必要な情報はしっかり記録できます。

### 3.3. null安全と入力値の検証

-   **`StringUtils.isNullOrBlank()`:** ユーザーの入力が`null`や空文字、空白のみでないかをチェックし、意図しないデータが登録されるのを防ぎます。
-   **`equalsIgnoreCase()`:** `"Q"`と`"q"`のように、大文字・小文字を区別せずに文字列を比較することで、利用者の入力の揺れを吸収し、より柔軟な操作を可能にします。

### 3.4. リソース管理の徹底

`try-with-resources`構文は、`Connection`や`Scanner`のような、使い終わったら必ず閉じる（`close()`する）必要があるリソースを、安全かつ確実に解放するための仕組みです。この構文を使うことで、`finally`ブロックで煩雑な`close()`処理を書く必要がなくなり、コードがシンプルになると同時に、リソースの閉じ忘れによるメモリリークなどの問題を未然に防ぐことができます。

### 3.5. printfによる書式制御

`ConsoleUtils.printItemList()`では、`System.out.printf()`を使って、IDと品目名を整列させて表示しています。`%3d`は「整数を3桁幅で右詰めで表示」、`%s`は「文字列をそのまま表示」といった書式指定子を使うことで、コンソール出力の見た目を綺麗に整えることができます。
